互斥量：类似一个窄门，同一时间只获得一个线程（可在多个进程中共享）
信号量：类似一个关卡，同一时间允许一定数量线程通过
事 件：播报任何线程都能收听的公共信号（用户输入时，或在开始、停止一个线程时）
临界区：类似互斥量，但只能在一个进程中使用



GetCurrentThreadId()



Windows API 使用 __stdcall 调用方式



TCHAR* szClassName=TEXT("TestDlg"); 



HANDLE handle = CreateThread(NULL,0,ThreadFun,NULL,NULL,NULL);
HANDLE CreateThread(
LPSECURITY_ATTRIBUTES lpThreadAttributes,//SD
SIZE_T dwStackSize,//initialstacksize
LPTHREAD_START_ROUTINE lpStartAddress,//threadfunction
LPVOID lpParameter,//threadargument
DWORD dwCreationFlags,//creationoption
LPDWORD lpThreadId//threadidentifier
)
lpThreadAttributes：指向SECURITY_ATTRIBUTES型态的结构的指针。在Windows 98中忽略该参数。在Windows NT中，NULL使用默认安全性，不可以被子线程继承，否则需要定义一个结构体将它的bInheritHandle成员初始化为TRUE
dwStackSize，设置初始栈的大小，以字节为单位，如果为0，那么默认将使用与调用该函数的线程相同的栈空间大小。任何情况下，Windows根据需要动态延长堆栈的大小。
lpStartAddress，指向线程函数的指针，形式：@函数名，函数名称没有限制，但是必须以下列形式声明：
DWORD WINAPI 函数名 (LPVOID lpParam) ，格式不正确将无法调用成功。
//也可以直接调用void类型
//但lpStartAddress要这样通过LPTHREAD_START_ROUTINE转换如： (LPTHREAD_START_ROUTINE)MyVoid
//然后在线程声明为：
void MyVoid()
{
return;
}
lpParameter：向线程函数传递的参数，是一个指向结构的指针，不需传递参数时，为NULL。
dwCreationFlags ：线程标志,可取值如下
（1）CREATE_SUSPENDED(0x00000004)：创建一个挂起的线程，
（2）0：表示创建后立即激活。
（3）STACK_SIZE_PARAM_IS_A_RESERVATION(0x00010000)：dwStackSize参数指定初始的保留堆栈 的大小，否则,dwStackSize指定提交的大小。该标记值在Windows 2000/NT and Windows Me/98/95上不支持。
lpThreadId:保存新线程的id。
返回值：函数成功，返回线程句柄；函数失败返回false。若不想返回线程ID,设置值为NULL。



WaitForSingleObject(handle,INFINITE);
DWORD WINAPI WaitForSingleObject(
__in HANDLE hHandle,
__in DWORD dwMilliseconds
);
hHandle[in]对象句柄。可以指定一系列的对象，如Event、Job、Memory resource notification、Mutex、Process、Semaphore、Thread、Waitable timer等。
dwMilliseconds[in]定时时间间隔，单位为milliseconds（毫秒）.如果指定一个非零值，函数处于等待状态直到hHandle标记的对象被触发，或者时间到了。如果dwMilliseconds为0，对象没有被触发信号，函数不会进入一个等待状态，它总是立即返回。如果dwMilliseconds为INFINITE，对象被触发信号后，函数才会返回。



handle[i] = (HANDLE)_beginthreadex(NULL, 0, ThreadFun, NULL, NULL, NULL);
绝对不要调用系统自带的CreateThread函数创建新的线程，而应该使用_beginthreadex，除非你在线程中绝不使用需要tiddata结构的运行时库函数



WaitForMultipleObjects(10, handle, TRUE, INFINITE);
DWORD WaitForMultipleObjects(
DWORD nCount,
const HANDLE* lpHandles,
BOOL bWaitAll,
DWORD dwMilliseconds
);



有些变量是用volatile关键字声明的。当两个线程都要用到某一个变量且该变量的值会被改变时，应该用volatile声明，该关键字的作用是防止优化编译器把变量从内存装入CPU寄存器中。如果变量被装入寄存器，那么两个线程有可能一个使用内存中的变量，一个使用寄存器中的变量，这会造成程序的错误执行。volatile的意思是让编译器每次操作该变量时一定要从内存中真正取出，而不是使用已经存在寄存器中的值



#define WINAPI __stdcall



CRITICAL_SECTION g_csThreadParameter, g_csThreadCode;
	InitializeCriticalSection(&g_csThreadParameter);
	InitializeCriticalSection(&g_csThreadCode);
		EnterCriticalSection(&g_csThreadParameter);//进入子线程序号关键区域
		LeaveCriticalSection(&g_csThreadParameter);
	DeleteCriticalSection(&g_csThreadCode);
	
	

HANDLE g_hThreadEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
HANDLE CreateEvent(
LPSECURITY_ATTRIBUTES lpEventAttributes,// 安全属性
BOOL bManualReset,// 复位方式
BOOL bInitialState,// 初始状态
LPCTSTR lpName // 对象名称
);
lpEventAttributes[输入]
一个指向SECURITY_ATTRIBUTES结构的指针，确定返回的句柄是否可被子进程继承。如果lpEventAttributes是NULL，此句柄不能被继承。
bManualReset[输入]
指定将事件对象创建成手动复原还是自动复原。如果是TRUE，那么必须用ResetEvent函数来手工将事件的状态复原到无信号状态。如果设置为FALSE，当一个等待线程被释放以后，系统将会自动将事件状态复原为无信号状态。
bInitialState[输入]
指定事件对象的初始状态。如果为TRUE，初始状态为有信号状态；否则为无信号状态。
lpName[输入]
指定事件的对象的名称，是一个以0结束的字符串指针。名称的字符格式限定在MAX_PATH之内。名字是对大小写敏感的。
如果lpName指定的名字，与一个存在的命名的事件对象的名称相同，函数将请求EVENT_ALL_ACCESS来访问存在的对象。这时候，由于bManualReset和bInitialState参数已经在创建事件的进程中设置，这两个参数将被忽略。如果lpEventAttributes是参数不是NULL，它将确定此句柄是否可以被继承，但是其安全描述符成员将被忽略。
如果lpName为NULL，将创建一个无名的事件对象。
如果lpName的和一个存在的信号、互斥、等待计时器、作业或者是文件映射对象名称相同，函数将会失败，在GetLastError函数中将返回ERROR_INVALID_HANDLE。造成这种现象的原因是这些对象共享同一个命名空间。



HANDLE hMutex = CreateMutex(NULL, TRUE, (LPCWSTR)MUTEX_NAME);
HANDLE CreateMutex(
LPSECURITY_ATTRIBUTES lpMutexAttributes, // 指向安全属性的指针
BOOL bInitialOwner, // 初始化互斥对象的所有者
LPCTSTR lpName // 指向互斥对象名的指针
);



_getch();
#include <conio.h>无回显的getchar()



HANDLE OpenMutex(
DWORD dwDesiredAccess, // access
BOOL bInheritHandle, // inheritance option
LPCTSTR lpName // object name
);
dwDesiredAccess：
MUTEX_ALL_ACCESS 请求对互斥体的完全访问
MUTEX_MODIFY_STATE 允许使用 ReleaseMutex 函数
SYNCHRONIZE 允许互斥体对象同步使用
bInheritHandle : 如希望子进程能够继承句柄，则为TRUE
lpName ：要打开对象的名字
返回值：如执行成功，返回对象的句柄；零表示失败。若想获得更多错误信息，请调用GetLastError函数。
备注：一旦不再需要，注意一定要用 CloseHandle 关闭互斥体句柄。如对象的所有句柄都已关闭，那么对象也会删除



HANDLE hMapping = CreateFileMapping((HANDLE)-1, NULL, PAGE_READWRITE, 0, sizeof(COMMUNICATIONOBJECT), COMMUNICATION_OBJECT_NAME);
HANDLE CreateFileMapping(
HANDLE hFile, //物理文件句柄
LPSECURITY_ATTRIBUTES lpAttributes, //安全设置
DWORD flProtect, //保护设置
DWORD dwMaximumSizeHigh, //高位文件大小
DWORD dwMaximumSizeLow, //低位文件大小
LPCTSTR lpName //共享内存名称
);
创建一个新的文件映射内核对象
hFile:Long，指定欲在其中创建映射的一个文件句柄。0xFFFFFFFF（-1，即INVALID_HANDLE_VALUE）表示在页面文件中创建一个可共享的文件映射。
lpFileMappigAttributes:SECURITY_ATTRIBUTES，它指明返回的句柄是否可以被子进程所继承，指定一个安全对象，在创建文件映射时使用。如果为NULL（用ByVal As Long传递零），表示使用默认安全对象。
flProtect:Long，下述常数之一：
PAGE_READONLY 以只读方式打开映射
PAGE_READWRITE 以可读、可写方式打开映射
PAGE_WRITECOPY 为写操作留下备份
可组合使用下述一个或多个常数：
SEC_COMMIT 为文件映射一个小节中的所有页分配内存
SEC_IMAGE 文件是个可执行文件
SEC_RESERVE 为没有分配实际内存的一个小节保留虚拟内存空间
dwMaximumSizeHigh:Long，文件映射的最大长度的高32位。
dwMaximumSizeLow:Long，文件映射的最大长度的低32位。如这个参数和dwMaximumSizeHigh都是零，就用磁盘文件的实际长度。
lpName:String，指定文件映射对象的名字。如存在这个名字的一个映射，函数就会打开它。用vbNullString可以创建一个无名的文件映射。
调用CreateFileMapping的时候可能会出现的GetLastError的相应错误：
ERROR_FILE_INVALID （错误_文件_无效）如果企图创建一个零长度的文件映射
ERROR_INVALID_HANDLE（错误_无效_处理） 内存空间的命名和现有的内存映射，互斥量，信号量，临界区有同名
ERROR_ALREADY_EXISTS （错误或已经存在）表示内存空间命名已经存在
在调用CreateFileMapping()时，可以用GetLastError()来检查其返回的错误信息。如果返回值为ERROR_ALREADY_EXISTS，则表示内存映射对象指定名字已经存在。有关其他返回值的意义见MSDN的详细说明。



PCOMMUNICATIONOBJECT pCommObject = (PCOMMUNICATIONOBJECT)MapViewOfFile(hMapping, FILE_MAP_WRITE, 0, 0, 0);
LPVOID WINAPI MapViewOfFile(
　　__in HANDLE hFileMappingObject,
　　__in DWORD dwDesiredAccess, 
　　__in DWORD dwFileOffsetHigh,
　　__in DWORD dwFileOffsetLow,
　　__in SIZE_T dwNumberOfBytesToMap
　　);
参数1：hFileMappingObject 为CreateFileMapping()返回的文件映像对象句柄。
参数2：dwDesiredAccess 映射对象的文件数据的访问方式，而且同样要与CreateFileMapping()函数所设置的保护属性相匹配。 可取以下值：
FILE_MAP_ALL_ACCESS 等价于CreateFileMapping的 FILE_MAP_WRITE|FILE_MAP_READ. 文件映射对象被创建时必须指定PAGE_READWRITE 选项.
FILE_MAP_COPY 可以读取和写入文件.写入操作会导致系统为该页面创建一份副本.在调用CreateFileMapping时必须传入PAGE_WRITECOPY保护属性.
FILE_MAP_EXECUTE 可以将文件中的数据作为代码来执行.在调用CreateFileMapping时可以传入PAGE_EXECUTE_READWRITE或PAGE_EXECUTE_READ保护属性.
FILE_MAP_READ 可以读取文件.在调用CreateFileMapping时可以传入PAGE_READONLY或PAGE_READWRITE保护属性.
FILE_MAP_WRITE 可以读取和写入文件.在调用CreateFileMapping时必须传入PAGE_READWRITE保护属性.
参数3：dwFileOffsetHigh 表示文件映射起始偏移的高32位.
参数4：dwFileOffsetLow 表示文件映射起始偏移的低32位.(64KB对齐不是必须的)
参数5：dwNumberOfBytes 指定映射文件的字节数.



UnmapViewOfFile(pCommObject);
BOOL WINAPI UnmapViewOfFile(_In_LPCVOID lpBaseAddress);
停止当前程序的一个内存映射。



STARTUPINFO startupInfoRed = { 0 };
指向一个用于决定新进程的主窗体如何显示的STARTUPINFO结构体。
PROCESS_INFORMATION processInformationRed = { 0 };
指向一个用来接收新进程的识别信息的PROCESS_INFORMATION结构体。
BOOL bSuccess = CreateProcess(TEXT("..\\Debug\\IPCWorker.exe"), TEXT("red"), NULL, NULL, FALSE, 0, NULL, NULL, &startupInfoRed, &processInformationRed);
BOOL CreateProcess
(
LPCTSTR lpApplicationName,
LPTSTR lpCommandLine,
LPSECURITY_ATTRIBUTES lpProcessAttributes,
LPSECURITY_ATTRIBUTES lpThreadAttributes,
BOOL bInheritHandles,
DWORD dwCreationFlags,
LPVOID lpEnvironment,
LPCTSTR lpCurrentDirectory,
LPSTARTUPINFO lpStartupInfo,
LPPROCESS_INFORMATIONlpProcessInformation
);
lpApplicationName
指向一个NULL结尾的、用来指定可执行模块的字符串。
这个字符串可以是可执行模块的绝对路径，也可以是相对路径，在后一种情况下，函数使用当前驱动器和目录建立可执行模块的路径。
这个参数可以被设为NULL，在这种情况下，可执行模块的名字必须处于 lpCommandLine 参数最前面并由空格符与后面的字符分开。
lpCommandLine
指向一个以NULL结尾的字符串，该字符串指定要执行的命令行。
这个参数可以为空，那么函数将使用lpApplicationName参数指定的字符串当做要运行的程序的命令行。
如果lpApplicationName和lpCommandLine参数都不为空，那么lpApplicationName参数指定将要被运行的模块，lpCommandLine参数指定将被运行的模块的命令行。新运行的进程可以使用GetCommandLine函数获得整个命令行。C语言程序可以使用argc和argv参数。
lpProcessAttributes
指向一个SECURITY_ATTRIBUTES结构体，这个结构体决定是否返回的句柄可以被子进程继承。如果lpProcessAttributes参数为空（NULL），那么句柄不能被继承。
在Windows NT中：SECURITY_ATTRIBUTES结构的lpSecurityDescriptor成员指定了新进程的安全描述符，如果参数为空，新进程使用默认的安全描述符。
lpThreadAttributes
同lpProcessAttribute,不过这个参数决定的是线程是否被继承.通常置为NULL.
bInheritHandles
指示新进程是否从调用进程处继承了句柄。
如果参数的值为真，调用进程中的每一个可继承的打开句柄都将被子进程继承。被继承的句柄与原进程拥有完全相同的值和访问权限。
dwCreationFlags
指定附加的、用来控制优先类和进程的创建的标志。以下的创建标志可以以除下面列出的方式外的任何方式组合后指定。
⑴值：CREATE_DEFAULT_ERROR_MODE
含义：新的进程不继承调用进程的错误模式。CreateProcess函数赋予新进程当前的默认错误模式作为替代。应用程序可以调用SetErrorMode函数设置当前的默认错误模式。
这个标志对于那些运行在没有硬件错误环境下的多线程外壳程序是十分有用的。
对于CreateProcess函数，默认的行为是为新进程继承调用者的错误模式。设置这个标志以改变默认的处理方式。
⑵值：CREATE_NEW_CONSOLE
含义：新的进程将使用一个新的控制台，而不是继承父进程的控制台。这个标志不能与DETACHED_PROCESS标志一起使用。
⑶值：CREATE_NEW_PROCESS_GROUP
含义：新进程将是一个进程树的根进程。进程树中的全部进程都是根进程的子进程。新进程树的用户标识符与这个进程的标识符是相同的，由lpProcessInformation参数返回。进程树经常使用GenerateConsoleCtrlEvent函数允许发送CTRL+C或CTRL+BREAK信号到一组控制台进程。
⑷值：CREATE_SEPARATE_WOW_VDM
如果被设置，新进程将会在一个私有的虚拟DOS机（VDM）中运行。另外，默认情况下所有的16位Windows应用程序都会在同一个共享的VDM中以线程的方式运行。单独运行一个16位程序的优点是一个应用程序的崩溃只会结束这一个VDM的运行；其他那些在不同VDM中运行的程序会继续正常的运行。同样的，在不同VDM中运行的16位Windows应用程序拥有不同的输入队列，这意味着如果一个程序暂时失去响应，在独立的VDM中的应用程序能够继续获得输入。
⑸值：CREATE_SHARED_WOW_VDM
如果WIN.INI中的Windows段的DefaultSeparateVDM选项被设置为真，这个标识使得CreateProcess函数越过这个选项并在共享的虚拟DOS机中运行新进程。
⑹值：CREATE_SUSPENDED
含义：新进程的主线程会以暂停的状态被创建，直到调用ResumeThread函数被调用时才运行。
⑺值：CREATE_UNICODE_ENVIRONMENT
含义：如果被设置，由lpEnvironment参数指定的环境块使用Unicode字符，如果为空，环境块使用ANSI字符。
⑻值：DEBUG_PROCESS
含义：如果这个标志被设置，调用进程将被当做一个调试程序，并且新进程会被当做被调试的进程。系统把被调试程序发生的所有调试事件通知给调试器。
如果你使用这个标志创建进程，只有调用进程（调用CreateProcess函数的进程）可以调用WaitForDebugEvent函数。
⑼值：DEBUG_ONLY_THIS_PROCESS
含义：如果此标志没有被设置且调用进程正在被调试，新进程将成为调试调用进程的调试器的另一个调试对象。如果调用进程没有被调试，有关调试的行为就不会产生。
⑽值：DETACHED_PROCESS
含义：对于控制台进程，新进程没有访问父进程控制台的权限。新进程可以通过AllocConsole函数自己创建一个新的控制台。这个标志不可以与CREATE_NEW_CONSOLE标志一起使用。
〔11〕值：CREATE_NO_WINDOW
含义：系统不为新进程创建CUI窗口，使用该标志可以创建不含窗口的CUI程序。
dwCreationFlags参数
还用来控制新进程的优先类，优先类用来决定此进程的线程调度的优先级。如果下面的优先级类标志都没有被指定，那么默认的优先类是NORMAL_PRIORITY_CLASS，除非被创建的进程是IDLE_PRIORITY_CLASS。在这种情况下子进程的默认优先类是IDLE_PRIORITY_CLASS。
可以选择下面的标志中的一个：
优先级：HIGH_PRIORITY_CLASS
含义：指示这个进程将执行时间临界的任务，所以它必须被立即运行以保证正确。这个优先级的程序优先于正常优先级或空闲优先级的程序。一个例子是Windows任务列表，为了保证当用户调用时可以立刻响应，放弃了对系统负荷的考虑。确保在使用高优先级时应该足够谨慎，因为一个高优先级的CPU关联应用程序可以占用几乎全部的CPU可用时间。
优先级：IDLE_PRIORITY_CLASS
含义：指示这个进程的线程只有在系统空闲时才会运行并且可以被任何高优先级的任务打断。例如屏幕保护程序。空闲优先级会被子进程继承。
优先级：NORMAL_PRIORITY_CLASS
含义：指示这个进程没有特殊的任务调度要求。
优先级：REALTIME_PRIORITY_CLASS
含义：指示这个进程拥有可用的最高优先级。一个拥有实时优先级的进程的线程可以打断所有其他进程线程的执行，包括正在执行重要任务的系统进程。例如，一个执行时间稍长一点的实时进程可能导致磁盘缓存不足或鼠标反映迟钝。
lpEnvironment
指向一个新进程的环境块。如果此参数为空，新进程使用调用进程的环境。
一个环境块存在于一个由以NULL结尾的字符串组成的块中，这个块也是以NULL结尾的。每个字符串都是name=value的形式。
因为相等标志被当做分隔符，所以它不能被环境变量当做变量名。
与其使用应用程序提供的环境块，不如直接把这个参数设为空，系统驱动器上的当前目录信息不会被自动传递给新创建的进程。对于这个情况的探讨和如何处理，请参见注释一节。
环境块可以包含Unicode或ANSI字符。如果lpEnvironment指向的环境块包含Unicode字符，那么dwCreationFlags字段的CREATE_UNICODE_ENⅥRONMENT标志将被设置。如果块包含ANSI字符，该标志将被清空。
请注意一个ANSI环境块是由两个零字节结束的：一个是字符串的结尾，另一个用来结束这个快。一个Unicode环境块是由四个零字节结束的：两个代表字符串结束，另两个用来结束块。
lpCurrentDirectory
指向一个以NULL结尾的字符串，这个字符串用来指定子进程的工作路径。这个字符串必须是一个包含驱动器名的绝对路径。如果这个参数为空，新进程将使用与调用进程相同的驱动器和目录。这个选项是一个需要启动应用程序并指定它们的驱动器和工作目录的外壳程序的主要条件。
lpStartupInfo
指向一个用于决定新进程的主窗体如何显示的STARTUPINFO结构体。
lpProcessInformation
指向一个用来接收新进程的识别信息的PROCESS_INFORMATION结构体。



HANDLE g_hThreadSemaphore = CreateSemaphore(NULL, 0, 1, NULL);
HANDLE CreateSemaphore(
    LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, // SD
    LONG lInitialCount, // initial count
    LONG lMaximumCount, // maximum count
    LPCTSTR lpName// object name
);
lpSemaphoreAttributes SECURITY_ATTRIBUTES，指定一个SECURITY_ATTRIBUTES结构，或传递零值（将参数声明为ByVal As Long，并传递零值）――表示采用不允许继承的默认描述符。该参数定义了信号量的安全特性
lInitialCount Long，设置信号量的初始计数。可设置零到lMaximumCount之间的一个值
lMaximumCount Long，设置信号量的最大计数
lpName String，指定信号量对象的名称。用vbNullString可创建一个未命名的信号量对象。如果已经存在拥有这个名字的一个信号量，就直接打开现成的信号量。这个名字可能不与一个现有的互斥体、事件、可等待计时器或文件映射的名称相符



